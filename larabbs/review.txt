【1】Laravel 提供的三种访问类的方式
依赖注入：通过类型提示的方式实现自动依赖注入

门面：通过代理来访问类

辅助函数：通过方法的方式来访问类
https://segmentfault.com/a/1190000009171779?utm_source=weekly&utm_medium=email&utm_campaign=email_weekly

【2】依赖注入，控制反转
https://insp.top/article/learn-laravel-container

【3】魔术方法：可以理解为比较神奇的方法，这些方法比一般的方法要神奇很多，具体怎么神奇，就看个人理解了
https://segmentfault.com/a/1190000007250604
https://www.php.net/manual/zh/language.oop5.magic.php

【4】反射api：---以后再看

【5】中间件的逻辑：每个请求都要经过中间件处理，有两种结果，通过或者不通过，中间件要放在构造函数中

【6】boot方法一般是静态的，类的初始化一般是放在__construct函数中，boot方法的执行一般在类的初始化之后

【7】php artisan make:migration create_tatuses_table --create=aaaa
这个命令会创建一个类名为CreateTatusesTable的迁移文件，迁移文件会创建一个名称为aaaa的数据表，不加--create=aaaa，表名默认取的是tatuses

【8】snake case蛇形命名法，就是用下划线e.x file_name
camel case驼峰命名法，就是第一个字母小写，剩下其他单词的第一个字母大写e.x fileNameName2

【9】命名空间都是用的反斜杠

【10】用户认证就是指通过Auth::attempt()来验证用户传给服务端的数据
已认证用户，就是指通过这个方法返回true的用户
attempt 方法的每个参数是一个关联数组。数组值用于在数据库中查找用户。在上面的例子中，将通过 email 列的值查找用户。如果找到该用户，将用存储在数据库中的哈希密码与数组中的 password 值做比较。不需要对 password 做哈希运算，框架在与数据库中的哈希密码做比较前自动对此值做哈希运算。如果两个哈希值匹配，将为该用户建立验证通过的 session。
如果验证成功， attempt 方法返回 true ，否则返回 false
在attempt方法里面不用再调用Auth::login()；
----因为attempt通过后会自动建立登录session会话

【11】Auth::login($user);
给一个用户实例创建登录session

【12】redirect() 带参数会返回 重定向 HTTP 响应，如果不带参数调用则返回重定向器实例

【13】请求中放的值的键都是前端name属性中的值

【14】belongsToMany是多对多关联
可以接受四个参数，
第一个是关联模型名，
第二个是中间表表名
第三个是定义关联的所在模型在中间表的外键名
第四个是关联模型在中间表的外键名
这个模型其实不需要中间表，只要逻辑是有三个表就可以
belongsToMany(User::class, 'followers', 'user_id', 'follower_id')
----如果不指定第二个参数，Eloquent 会默认中间表为按照字母顺序连接两个关联模型的名字


【15】$user->followings和$user->followings()的区别
ps:follonwings是定义在模型中的关联方法
https://learnku.com/laravel/t/8035/should-there-be-three-tables-for-many-to-many-relationships-how-can-a-users-table-and-an-intermediate-table-followers-and-fan-list-follower-be-not-if-not-how-do-i-connect-them
也就是说动态属性访问关联模型返回的是 Eloquent：集合，而如果我们直接调用方法返回的则是 数据库请求构建器（也就是查询构造器？）。

【16】laravel集合
主要是为了链式调用函数来处理数组元素，他和数组类似，但并不是数组它是类；
所有 Eloquent 的集合都继承了 Laravel Collection 对象；因此，他们也继承了所有集合基类提供的强大的方法；
----注意：大多数 Eloquent 集合方法会返回新的 Eloquent 集合实例，但是 pluck, keys, zip, collapse, flatten 和 flip 方法除外，它们会返回一个 集合基类 实例。
同样，如果 map 操作返回的集合不包括任何 Eloquent 模型，那么它会被自动转换成集合基类

【17】预加载和懒加载
加载是针对内存来说的
https://learnku.com/docs/laravel/7.x/eloquent-relationships/7500#eager-loading

【18】trait怎么使用
先在类的上面用 use trait的完全限定名称
然后，在类里面用  use trait非完全限定名称 
trait也可以像上面那样使用，trait也可以调用trait
----优先顺序是来自当前类的成员覆盖了 trait 的方法，而 trait 则覆盖了被继承的方法

【19】??     当 expr1 为 null，表达式 (expr1) ?? (expr2) 等同于 expr2，否则为 expr1

【20】可以省略三元运算符中间那部分。表达式 expr1 ?: expr3 在 expr1 求值为 true 时返回 expr1，否则返回 expr3。

【21】insteadof
为了解决多个 trait 在同一个类中的命名冲突，需要使用 insteadof 操作符来明确指定使用冲突方法中的哪一个
e.x  
 use A, B{
        B::smallTalk insteadof A;
        A::bigTalk insteadof B;
    }
意思是使用B中的smallTalk函数，放弃A中的这个函数，下面那个一样

【22】{}  双引号引起来的大括号中的变量，是按变量来解析的，并不是字符串
e.x $var = 'name';   $boo = "x{$var}" 
$boo为 xname

【23】接口和抽象类主要区别
一个类可以继承多个接口，而一个类只能继承一个抽象类！

【24】抽象类
继承一个抽象类的时候，子类必须定义父类中的所有抽象方法；另外，这些方法的访问控制必须和父类中一样（或者更为宽松）
----类中必须实现接口中定义的所有方法，否则会报一个致命错误

【25】定义常量
你可以用 define() 函数，或 const 两种方法来定义一个常量
常量不用加美元符号
https://www.php.net/manual/zh/language.constants.syntax.php

【26】类中的静态方法和属性，主要作用就是可以不实例化，直接调用

【27】当以属性方式（指动态属性，如$user->followings（followings是模型中定义的关联方法））访问 Eloquent 关联时，关联数据「懒加载」
这时就要使用预加载来解决关联模型查询时出现的N+1问题
就是调用模型的静态方法with，e.x  User::with('followings')
ps:followings是模型中定义的关联方法

【28】每个 Eloquent 模型都相当一个查询构造器，查询构造器实例可以调用诸如get(),where()，pluck()等函数

【29】Eloquent 返回的所有结果集都是 Illuminate\Database\Eloquent\Collection 对象的实例包括通过 get 方法检索或通过访问关联关系(这里应该是指通过动态属性返回的)获取到的结果

【30】Eloquent其实就是模型，每个数据库表都有一个对应的「模型」用来与该表交互

【31】html  form中get和post区别
get       form默认该方法。将表单数据（form-data）以名称/值对的形式附加到 URL 中：URL?name=value&name=value。
post     以 HTTP post 事务（事务，在这里可以理解成sql语句）的形式发送表单数据（form-data）。

【32】 Memcached 和 Redis   都是后端缓存驱动

【33】抽空总结下laravel启动过程
https://learnku.com/docs/laravel/7.x/lifecycle/7453
https://blog.csdn.net/yu_20170610/article/details/104903479

【34】初始化就是指给变量赋值，类的初始化也是如此，只不过类的初始化，有时候会放在类的构造函数中

【35】事件分发  你可以将事件实例传递给 event 辅助函数。该辅助函数将会把事件分发到所有该事件已注册的监听器上，event 辅助函数可以全局使用
e.x  event(new OrderShipped($order))   $order是模型实例

【36】上面的例子中事件都会保存模型实例为自己的属性，然后监听器会通过在handle函数中传递一个对应事件的类型提示参数，然后这个参数会在一堆实例中，通过反射来找到对应的类

【37】模型事件的三种实现方法
1.在模型中使用 $dispatchesEvents 属性去注册事件对象
e.x
protected $dispatchesEvents = [
    'saving' => \App\Events\UserSaving::class,
];


【38】instanceof用于确定一个变量是不是某个类或者实现了某个接口的类的实例

【39】模型中update和save的区别
update是批量赋值，并未实际生成模型实例，不会触发模型事件
save会触发模型事件saved

【40】若要获取上一次请求所保存的旧数据，可以在 Request 的实例上使用 old 方法
e.x  $username = $request->old('username');
也可以使用Laravel 提供的全局辅助函数 old（其实这个函数里面调用的还是request->old('parameter')）
e.x  <input type="text" name="username" value="{{ old('username') }}">
----这个方法可以有第二个参数，用来作为默认值，就是打开编辑页面的输入框里面的值

【41】所有服务提供者都是通过配置文件 config/app.php 进行注册
放在providers中，第一步，所有服务提供者的 register 方法会被调用，然后一旦所有服务提供者均注册后， boot 方法才被调用

【42】两种解析类实例的方法，
一个是$this->app->make(类的完全限定名)(在服务提供者中，你总是可以通过 $this->app 属性访问容器)
另一个是全局辅助函数resolve(类的完全限定名)

【43】config/app.php文件中的别名（aliases）注册后，就可以在任何地方通过use+别名来引入这个类，别名是懒加载，不会影响性能

【44】关于绑定和解析的理解
app()->bind('rice', function (){
    return new \App\Rice();
});
----绑定还有另外一种方式，就是把两个类绑定起来，e.x bind(User::class, Data::class)
把‘rice’绑定到一个闭包，这个闭包会返回一个类的实例
Route::get('eat', function() {
       
       return app()->make('rice')->food(); 
       // 或者 return resolve('rice')->food()；

});
然后通过make函数传递一个键名来调用这个闭包，就生成了一个类的实例

【45】Facade的实现方式，
----原类要先注册到容器中
首先定义一个类，这个类要继承Facade类，类的命名可以是原类名+Facade，然后在getFacadeAccessor()（static方法）方法中返回原类在容器中注册的键名
，这样就可以了，一般还会再为原类名+Facade定义一个别名，这样就可以
use+别名来引用了，不过上面创建的门面并不会自动创建别名
然后当调用门面的不存在的静态方法是，先是会调用一个__callStatic魔术方法,然后__callStatic()这个魔术方法中会间接调用getFacadeAccessor()方法，这个方法仅仅返回一个容器中的一个键名，然后返回给容器来解析，然后容器就返回键名对应的实例，然后实例调用自己的和上面门面调用的静态方法同名的非静态方法

【46】类的依赖不一定是类，可以是任何数据类型

【47】自动依赖注入：现在只知道是通过反射来实现的，具体怎么实现不知道，在laravel中是通过类型提示来是使用自动依赖注入

【48】重定向在哪里修改
一般要想改重定向的话，是在对应的控制器上，重写protected $redirectTo属性就行

【49】控制反转是一种解决问题的思路，而依赖注入就是这种思路的具体实现

【50】
--简单绑定$this->app->bind(),参数是什么
--绑定一个单例$this->app->singleton(),这个的意思是只解析一次，后续的对它的解析都将返回第一次解析的实例，参数是什么
--绑定实例$this->app->instance(),参数是什么
--绑定基本值    这个应该很少用，就是给类传参数用的
--绑定接口到实现$this->app->bind(),参数是什么
e.x
$this->app->bind(
    'App\Contracts\EventPusher',
    'App\Services\RedisEventPusher'
);
这个是指当一个类需要实现 EventPusher 时，应该注入 RedisEventPushe
--上下文绑定  这个就是指当多个类都使用了同一个接口（例如通过接口类型提示传参），但是每个类都要求注入这个接口的不同实现，此时就用这个
--标记   $this->app->tag(['SpeedReport', 'MemoryReport'], 'reports');
就是指‘打包’，把类似的注册，归为一类；具体用在哪里不知道，['SpeedReport', 'MemoryReport']这两个就是通过bind注册的类，把他们归为reports
--扩展绑定$this->app->extend()
extend 方法可以修改已解析的服务。比如，当一个服务被解析后，你可以添加额外的代码来修饰或者配置它。 
extend 方法接受一个闭包，该闭包唯一的参数就是这个服务， 并返回修改过的服务

【51】中间件除了过滤请求的作用外，还有重定向的功能，不通过会被重定向到另一个页面

【52】命名空间的三种方式，重点
https://www.php.cn/blog/detail/26466.html
https://www.php.net/manual/zh/language.namespaces.basics.php
【53】require和include区别
假如a.php文件中有return；b.php文件中没有return
然后
$a = include 'a.php';
$b = include 'b.php';
那么$a,$b的值分别为什么
https://www.php.net/manual/zh/function.include.php

【54】中间件是在请求之前或之后执行，取决于中间件本身，是怎么实现的？
https://learnku.com/docs/laravel/7.x/middleware/7459

【55】Laravel 的入口文件是哪个，这个文件主要是来干什么用的
index.php 文件加载 Composer 生成的自动加载设置，然后从 bootstrap/app.php 脚本中检索 Laravel 应用程序的实例。 Laravel 本身采取的第一个动作是创建一个应用程序 / 服务容器
----Application 类继承自 Container 类，所以创建的应用实例可以使用容器的方法，同时app实例是唯一的

【56】有两个注册ServiceProvider和别名的地方
一个是config/app.php文件的providers和aliases
另一个是composer.json中的extra->laravel->providers
和extra->laravel->aliases


【57】当文件中同时出现__autoload和spl_autoload_register时，以spl_autoload_register为准
----__autoload自 PHP 7.2.0 起被废弃，并自 PHP 8.0.0 起被移除

【58】__autoload和spl_autoload_register的区别
https://learnku.com/articles/4681/analysis-of-the-principle-of-php-automatic-loading-function

【59】栈和堆的区别
----栈和堆都是内存的一部分，它们只不过是不同的逻辑结构
 栈（stack）：有编译器自动分配和释放，存放函数的参数、局部变量、临时变量、函数返回地址等；

 堆（heap）：一般有程序员分配和释放，如果没有手动释放，在程序结束时可能由操作系统自动释放

【60】spl_autoload_register ()
这个函数主要作用就是把它的参数(一般是一个函数回调)，写入到堆栈中，然后当调用的类名在当前文件中未定义时，会调用这个堆栈，依次执行堆栈中的函数
----这个回调函数有一个参数，默认为不存在的类的完全限定名

如果我们不向这个函数输入任何参数，那么就会注册 spl_autoload () 函数

spl_autoload 就是 SPL 自己的定义 _autoload () 函数，功能很简单，就是去注册的目录 (由 set_include_path 设置) 找与 classname 同名的 .php/.inc 文件
----有两种传参方式，一种是传一个函数名称（用引号引起来）
另一种是传一个数组，数组第一个值是类名，第二个值是类中的函数名
e.x     [$this, 'foo'] or ['ClassName', 'foo']

【61】__NAMESPACE__ 魔术常量和 namespace 关键字区别
__NAMESPACE__ 就是常量，和变量的用法一样，它的值是一个字符串
namespace不能当常量用，他有俩个用法，一个是定义命名空间时，一个时当当前命名空间的关键字使用

【62】PSR-4    命名空间规范
https://www.kancloud.cn/thinkphp/php-fig-psr/3144
--完全限定的类名中，去掉最前面的命名空间分隔符，前面连续的一个或多个leading namespace和子命名空间，作为“命名空间前缀”，其必须与至少一个“文件基目录”相对应
--“ namespace prefix”后面的连续子名称空间名称对应于“ base directory”中的子目录，其中名称空间分隔符表示目录分隔符。子目录名称必须与子命名空间名称的大小写相匹配
--namespace prefix（命名空间前缀）
--leading namespace(应该是指顶级命名空间？?)
--base directory是人为定义的，名字可以任意取，可以是多层的文件路径

【63】如果没有参数要传递给类的构造函数，创建实例时类名后的括号则可以省略掉

【64】后期静态绑定
https://learnku.com/articles/8964/understanding-of-static-binding-at-the-later-stage-of-php
看下自己的评论

【65】use其实导入的并不是关于类的定义代码，而是这个类的完全限定名称
当需要用到这个类时，它会在当前文件中查找这个完全限定名称的类

【66】全局空间就是最顶层的空间，它是所有命名空间的顶部，一般用反斜杠表示e.x  '\'

【67】如果没有定义任何命名空间，所有的类与函数的定义都是在全局空间

【68】如果定义了命名空间，假如是namespace Kakaxi;
若在此命名空间中用限定类名调用一个类，比如 Cname::test();
那么这个类会解析为\Kakaxi\Cname

【69】假如给类起一个别名，e.g. \App\Kaa\Cname   alias as Cname
那么在没有定义命名空间时，就可以不用use直接用Cname来调用这个类（require动态加载）
如果，定义了命名空间，那么就要用use Cname来引入这个类

【70】当我们执行git push没有指定分支时，自动使用当前分支，而不是报错。
git config --global push.default simple

【71】git 中的origin代表什么意思
origin指向的是一个远程仓库，远程仓库就是一个链接e.x https://github.com/user1/repository.git
可以理解为 远程仓库链接的别名，链接太长用起来麻烦